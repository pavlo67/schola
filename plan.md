# План занять

[Всі конспекти до занять](https://github.com/pavlo67/schola/tree/master/lessons) — в процесі розробки, звісно ж.

## A. Загальне (все це може бути потім деталізовано в окремі розгляди).

A.1. Побіжний огляд — програмування як:
- мистецтво (зокрема — алгоритм двох стеків Дейкстри, пошук по списку з результатом пошуку в якості стоп-елемента, обробка дерева з допомогою рекурсії в глибину чи в ширину vs. обробка дерева з допомогою стеку чи черги тощо), ієрархічні конструкції;
- наука (зокрема — складність алгоритмів, спроби аксіоматизації, декремент циклу тощо);
- ремесло (зокрема — планування роботи, акуратність і правила стилю, тести і відладка тощо).

A.2. Побіжний огляд — історія мов і концепцій програмування:
- перші компʼютери і перші високорівневі мови - фортран, алгол, лісп;
- продуктивність і системи вводу-виводу ранніх компʼютерів;
- компільовані та інтерпретовані мови; процедурні, функціональні і логічні мови; віртуальна машина;
- оцінки вартости програмних систем, ціна помилок, бум мов програмуванні і методології в 70-х;
- структурне та ієрархічне програмування, відмова від goto;
- багатопоточність / паралельне програмування;
- ООП;
- Model-View-Controller;
- модульне програмування, інтерфейси;
- клієнт-сервер.

А.3. Побіжний огляд — історія інтернету, персональних компʼютерів, особливості програмного та інтернет-бізнесу.

А.4. Побіжний огляд — робота і бізнес в IT. Погляд підприємця-роботодавця, тім-ліда, члена команди, кандидата... Результати, повага до чужого часу і зусиль (кожне запитання спершу задається своїй історії повідомлень і гуглу), співпраця, звертання-відповідь, запитання-автономність (прості і складні питання — запуск прикладу vs. add-on в Magento, OAuth, callbacks). Завершення завдань за скінченний час. Прості і загальнодоступні рішення.


## B. Методи.

B.1. [Розробка і помилки. Ідеал: TDD/BDD, "Test first / docs first." Реальність: "в бізнесу ніколи немає грошей, щоб розробити
систему як слід, проте вони завжди знаходяться, щоб розробити її двічі." Рекомендація: розробка — спершу в голові; чіткість 
планів.](lessons/b1.clarity.md)

B.2. [Цілі розробки. Рекомендація — чек-ліст по порядку (елементарної) розробки і структурі коду: постановка задачі, функція, 
пускач, тест-кейси, тести...](lessons/b2.targets.md) 

B.3. [Юніт-тести](lessons/b3.tests.md)

B.4. Стиль оформлення коду: форматування (зокрема — стандарти і авто-форматери), лінтери. Програма для читача, програма для 
дебагу-підтримки vs. програма для машини. Гівнокод.

B.5. Ієрархічна побудова, проєктування "зверху-вниз". Структурне програмування (швидкодія vs. ціна підтримки). Single responsibility. 

B.6. Відладка. Контрольні виводи vs. інтегрований відладчик; уявна прокрутка; STDOUT/STDERR і логи (чистота!); трасування в розподілених системах; прогулянка-роздуми як 
найсильніший хід. Сильна типізація в мові програмування — мінус половина проблем при відладці.

B.7. Контроль. Вхідні параметри програми, вхідні параметри функцій, типи і структури в нетипізованій мові. JS: if (str == "undefined")... Ціна типізації в аспекті швидкодії.

B.8. Параметризація коду - "magic numbers", константи, конфіги. 

B.9. Дублювання коду і помилок vs. суміщення коду і побічні ефекти. Процедурна ієрархія.

B.10. Інтерфейси, поліморфізм, наслідування. Composition over inheritance. "Види інтерфейсів" в Go. Pros and cons.

B.11. Процедурна / обʼєктна структура коду. ООП, SOLID.

B.12. Архітектура системи: Model-View-Controller. Patterns (шаблони, зразки, моделі).

B.13. Модульна/пакетна структура системи: публічні репозиторії і каталоги (NPM), внутрішня структура, Dependency Injection.

B.14. Юніт-тести та інтегральне тестування (ціна помилки: хвилина при компіляції - година при тестуванні - день при відладці), 
API-тестування, ручне тестування (QA). Тести — підтверджують помилки, але, принципово, не можуть підтвердити їх відсутність. 

B.15. Документація та коментування (зокрема: історія RFC, коментарі в Go, doc-strings в JS/Python). Кращий коментар — добрий код. Але — необхідне коментування мотивів і девіяцій.

B.16. Типічні помилки в розробці і критерії оцінки: швидкість vs. надійність :-); "майже робоча система"; читабельність і красота коду; стабільність системи і легкість 
підтримки-відладки... 

B.17. KISS. YAGNI. If it ain't broke, don't fix it.

B.18. Життєвий цикл розробки і підтримки. Формулювання вимог, дизайни. Agile, scrum, waterfall, kanban... PoC, MVC, alpha-beta releases, release-candidate, release. Оточення: 
develop, test, stage, production. Тести, контроль цілісности, аналіз невдач ("post mortem").


## C. Кодування: структури програм і даних, алгоритми.

C.1. [Як освоювати Go (мотиви вибору), необхідний інструментарій, приклад коду](lessons/c1.intro.md).

C.2. Масив і список, імплементація та швидкодія. Цикл по масиву, вічний цикл (проблема на tradistar.com), декремент циклу. Пошук по масиву, сортування масиву.

C.3. Багатовимірний масив; цикли по багатовимірному масиву, множення матриць.

C.4. Структура vs. асоціятивний масив (Go map, JS object, Python dict, Perl hash). Швидкодія!

C.5. Значення і вказівники. Передача параметрів по вказівнику (посиланню) і по значенню. Обʼєкти-"константи" (зокрема, в JS). 

C.6. Виклик функції — що під капотом. Стек даних, стек повернень, області видимости.

C.7. Класи/обʼєкти, замикання (closures).

C.8. Функції роботи зі списками: map, grep/filter, sum, zip, list comprehension... "Лямбда-вирази".

C.9. Рядки і регулярні вирази.

C.10. Деревовидні структури і, на загал, графи. Рекурсія.

C.11. Стек (LIFO) і черга (FIFO). Реалізаціця рекурсії стеком, алгоритм двох стеків Дейкстри; callback-цикл в Node.js. Стек повернень і стек даних.

C.12. Типічні проблеми: вічний цикл (проблема на tradistar.com), вічна рекурсія ("maximun stack size exceeded"), memory leaks, +-1 на індексі циклу, декларування, області видимости і змішування імен змінних (JS: hoisting, "let" vs. "var").

C.13. Одно- і багатопоточний код. Thread-safe functions. Dead lock, data race. Мʼютекси і критичні секції, канали.

C.14. Колбеки, проміси, async-await. 

C.15. Представлення часу: проблеми з часовими поясами (Clickhouse, датасети) vs. unix timestamp.

C.16. Пошук: перебір vs. бінарний пошук vs. пошук по індексу vs. ще якось? оцінки швидкости. 

C.17. Сортування: бульбашкове vs. сортування вставкою vs. швидке vs. сортування злиттям vs. ще якось? оцінки швидкости. 

C.18. Індексація: збалансовані дерева (B-tree, червоно-чорні дерева), ще щось? оцінки швидкости. 

C.19. Архітектура БД: схема, індекси, foreign keys, нормалізація-денормалізація, тригери.

C.20. Архітектура системи: моноліт - мікросервіси. Внутрішні протоколи звʼязку.

C.21. Загальне: ієрархія (зокрема: фронт-бек, стек мережевих протоколів...), швидкодія vs. необхідний обʼєм памʼяти, швидкість розробки vs. ціна підтримки.



## D. Інструменти. 

D.1. Принципи вибору. Консерватизм vs. new features (тільки необхідне — "Try to do better. By Mick", фреймворки, ORM, IDE, debugger, мій "JSON", ETL-інструменти). Google в поміч :-) Stack Overflow. Slack vs. Skype (форматування, аларми / відмітка прочитання, груповий відео чат, якість звʼязку, зайві вікна, необхідність для привату).

D.2. Побіжний огляд базового інструментарію — IDE (VS Code, IntelliJ IDEA, Atom, Eclipse, NetBeans, VIM, Emacs), менеджери пакетів (NPM/Yarn - package.json/package-lock.json, Go modules - go.mod/go.sum, Python PIP), debugger, profiler, version control (Git, GitHub, GitLab, Bitbucket), project management (Trello, JIRA, Confluence), що ще я забув?

D.3. Version control: Git, GitHub, GitLab, Bitbucket. Коміти, гілки, merge (pull) requests, .gitignore, .gitkeep, checkout/branch/fetch/push/pull/diff/merge/reset... Git flow.  

D.4. Типізовані і нетипізовані, компільовані та інтерпретовані мови програмування. Під капотом - асемблер, байт-код, JIT-компіляція. Етап компіляції vs. runtime. Перехід з Node.js на Golang — апріорні перестороги, швидкодія, простота відладки.

D.5. Фреймворки: для Node.js - Express (KOA, Loopback, etc.), для фронт-енда — Angular/React/Vue (React Native), для Python - Django/Flask... Тестові фреймворки, OpenAPI (Swagger).

D.6. Бази даних: SQL (PostgresSQL, MySQL, Amazon Redshift, Google BigQuery) vs. NoSQL (document DB - MongoDB, key-value storages); client-server vs. embedded DB (SQLite, key-value storages); ORM. https://db-engines.com/en/ranking

D.7. Third-party APIs. Власний кодинг vs. сторонні інструменти. Освоєння — від найпростішого. Правило для спеціялістів: "якщо нічого иншого не допомагає, спробуйте почитати документацію".

D.8. Кешування, in-memory DB (Redis). Швидкодія!

D.9. Мови серіялізації та конфігів: JSON, Protobuf, YAML, XML тощо.

D.10. WWW: Email, FTP, Telnet/SSH, HTTP, HTML/HTML5, Wiki markup...

D.11. Клієнт-серверні протоколи: REST, GRPC, GraphQL... Web-сервер: REST vs. HTML pages generation.

D.12. Хостинг (AWS, Google Cloud, місцеві провайдери), Cloud/SaaS-інструменти (Google Firebase, AWS S3, AWS Lambda, etc.)

D.13. Деплоймент — конвеєри, тести, бекапи, моніторинг/метрики...


## E. Практика.

E.1. [Елементарні приклади/вправи з програмування](lessons/e1.examples.md).  

E.2. Web-сервер. Розробка сервера для цих курсів.

E.3. ETL (extract-transform-load). Розробка системи збору новин.


## F. Розбір самостійних робіт.

F.1. ["Сортування бульбашкою" за допомогою C++](exercices/f1.bubble_sort.cpp.md).  
