# B.4. Проєктування "згори-донизу", ієрархічна будова коду

## Джерела

В значній мірі підходи, представлені в цьому курсі, повторюють викладене в книзі
Йодан Э. "Структурное проектирование и конструирование программ", Москва, "Мир", 1979 
("Techniques of Program Structure and Design" Edward Yourdon, Prentice-Hall, 1975).

Зокрема, темі проєктування "згори-донизу" присвячено розділ "Нисходящее проектирование" (базовий 
розбір теми — ст. 53-62).

Едвард Йодан був вчителем для багатьох. Ось, наприклад: https://www.itweek.ru/idea/blog/idea/8316.php 
("...именно этого человека я всю жизнь считал и считаю сейчас своим главным учителем в области создания 
ПО...").


## Метод

Полягає в послідовній деталізації коду починаючи від запису його у вигляді найзагальніших кроків 
(можна починати проєктування навіть з запису гіпотетичної команди "Компʼютере! Зроби все, як треба!") з 
поступовим описом кожного кроку як послідовності менших (не конче деталізованих остаточно) і так далі, 
аж поки рівень деталізації кожного кроку не стане достатнім для того, щоб імплементувати його програмно.  

Цей метод є винятково корисним при проєктуванні великих систем, але й при розробці малих програм він 
також є цілком придатним і, в деяких випадках, виявляється просто необхідним. 

Розробка невеликих програм "згори-донизу" добре комбінується з [юніт-тестуванням](./b3.unit_tests.md), 
зокрема з "red-green testing". Окремі функції, які ще не є імплементованими, в процесі такої розробки 
заміняються на заглушки, які, в залежності від контексту, можуть не виконувати потрібні функції або 
виконувати їх частково правильно. Все це продемонстровано в наступному прикладі.       

Про функції-заглушки: https://uk.wikipedia.org/wiki/%D0%A4%D1%83%D0%BD%D0%BA%D1%86%D1%96%D1%8F-%D0%B7%D0%B0%D0%B3%D0%BB%D1%83%D1%88%D0%BA%D0%B0


## Ієрархічна будова коду

Результатом розробки "згори-донизу", як правило, є програма, в якій окремі рівні деталізації завдання 
представлені кожен своєю функцією. Така ієрархічна структура має і плюси, і мінуси. 

Серед плюсів відзначу дуже важливі:

* зручність читання коду і навігації по ньому, коли ієрархія не є аж надто подрібненою;
* зручність відладки кожної функції по окремості і разом з "підлеглими рівнями" (будь то фінально 
  імплементовані функції чи функції-заглушки);
* низька вартість відладки і підтримки (правильно ієрархічно побудованого) коду як наслідок 
  двох попередніх пунктів.   

А серед мінусів відзначу:

* незручність читання коду і навігації по ньому, коли ієрархія є аж надто подрібненою 
  (характерна помилка новачків);
* зменшення загальної швидкодії через виклики великої кількості функцій, що є звичайною  
  платою за зменшення ціни відладки-підтримки.
  
Взагалі, щодо останнього, то альтернатива "швидкодія коду vs. ціна розробки-підтримки"
є характерною, треба думати, для всіх без винятку методів розробки програм. Починаючи від 
переходу з асемблера на розробку з допомогою високорівневих мов — такий перехід істотно 
сповільнює отримані коди, але й радикально удешевляє розробку-підтримку (при цьому певні 
критичні в сенсі швидкодії секції в великих системах можуть бути написані й на асемблері — 
щось бо за щось...) 


## Приклад розробки згори-донизу: пошук простих чисел не більших ніж N за допомогою "решета Ератосфена". 

[Код](../examples/b4/sieve.go)
[Тест](../examples/b4/sieve_test.go)

Про решето Ератосфена: https://uk.wikipedia.org/wiki/%D0%A0%D0%B5%D1%88%D0%B5%D1%82%D0%BE_%D0%95%D1%80%D0%B0%D1%82%D0%BE%D1%81%D1%84%D0%B5%D0%BD%D0%B0

### Послідовність розробки.

При реальній розробці кожен настпний етап полягає, зазвичай, просто в переписуванні вихідної
функції без зміни назви і без зміни тестів. Але для прикладу всі функції тут перейменовані.
Тести при цьому, як видно, ідентичні (відрізняються лиш іменем основної функції, яку кожен з них
викликає).

### Перша версія

Функція (заглушка) SieveV1(), тест — TestSieveV1(). 

Спроєктовано сигнатуру функції (назва, список/типи вхідних параметрів і результатів), Зроблено тест-кейси і 
написано тест, який без змін використовуватиметься аж до завершення розробки.

Функція SieveV1() повертає порожній список знайдених простих чисел і, відтак, успішно проходить ті тест-кейси, в яких має буто повернуто порожній список, але, звісно, не 
проходить жоден змістовний тест.    

    === RUN   TestSieveV1
    sieve_test.go:30: testing n = -5
    sieve_test.go:30: testing n = -1
    sieve_test.go:30: testing n = 0
    sieve_test.go:30: testing n = 1
    sieve_test.go:30: testing n = 2
    sieve_test.go:32: 
        	Error Trace:	sieve_test.go:32
        	Error:      	Not equal: 
        	            	expected: []int{2}
        	            	actual  : []int{} 
                            ...
        	Test:       	TestSieveV1
    --- FAIL: TestSieveV1 (0.00s)
    Expected :[]int{2}
    Actual   :[]int{}

### Друга версія

Функція SieveV2(), тест — TestSieveV2(). 

Спроєктовано кроки, з яких буде складатись виконання функції, сигнатури відповідних функції 
і структури даних дя них (в даному прикладі це одна структура — "type sieve struct ...")

SieveV2() — це вже не заглушка, а реальна функція, яка без змін залишиться в фінальній версії коду. 
Але оскільки вона викликає функції-заглушки, то і повертає (так само як і попередня версія) 
порожній список знайдених простих чисел і так само не проходить тест.


### Третя версія

Функція SieveV3(), тест — TestSieveV3().

В цій версії повноцінно реалізовано перший крок InitSieveV3(), який без змін перейде 
в фінальну версію, а в останньому кроці вставлено контрольний вивід, щоб перевірити, чи коректно 
виконується перший крок. Щоб тест не впав на першому ж змістовному кейсі в заглушку останнього 
кроку додано вивід правильних значень для пари перших змістовних тест-кейсів — таким чином
тест проходить декілька кейсів і можна пересвідчитись, що перший крок відпрацьовує як слід 

    === RUN   TestSieveV3
    sieve_test.go:48: testing n = -5
    final sieve to get primes: e2.sieve{}

    sieve_test.go:48: testing n = -1
    final sieve to get primes: e2.sieve{}

    sieve_test.go:48: testing n = 0
    final sieve to get primes: e2.sieve{}

    sieve_test.go:48: testing n = 1
    final sieve to get primes: e2.sieve{}

    sieve_test.go:48: testing n = 2
    final sieve to get primes: e2.sieve{true}

    sieve_test.go:48: testing n = 3
    final sieve to get primes: e2.sieve{true, true}

    sieve_test.go:48: testing n = 5
    final sieve to get primes: e2.sieve{true, true, true, true}

    sieve_test.go:50:
        Error Trace:	sieve_test.go:50
        Error:      	Not equal:
                        expected: []int{2, 3, 5}
                        actual  : []int{}
                        ...
        Test:       	TestSieveV3
    --- FAIL: TestSieveV3 (0.00s) 
    Expected :[]int{2, 3, 5}
    Actual   :[]int{}


### Фінальна версія

Функція Sieve(), тест — TestSieve().

В цій версії повноцінно імплементовано всі кроки і вона успішно проходить тест.


### Зауваження щодо коду

Контрольний вивід зроблено з такими "\n"-відступами, що тестовий лог зручно читати. Це 
дрібничка, але вона дуууже важлива. Взагалі, акуратність формування програмних логів економить 
багато часу і зусиль при розробці.

В коді є мінімум коментарів — прокоментовано тільки слизькі місця, повʼязані із розміром списку 
та індексами в ньому. Проблема тут в тому, що список чисел від 2 до N, який проходить через 
решето, має довжину N-1, а кожне число M, представлене в ньому, має індекс M-2 — такі нюанси, 
безумовно, варто коментувати.  

В коді також є трохи закоментованого невикористовуваного коду — в реальній розробці це вважається 
поганим стилем і, дійсно, створює певні ускладнення. Але тут цей фрагмент лиш демонструє, що 
перевірку з нього не слід ставити у функції верхнього рівня, але — на тому рівні, де виконання 
чи невиконання відповідної умови може привести до збою у програмі. Тобто при перевірці нагорі 
програма так само працюватиме і матиме навіть вищу швидкодію — але ціною цього є ризик 
отримати в процесі виконання, якщо в програму будуть внесені зміни і функція, де ця перевірка важлива, 
виявиться викликаною в обхід такої перевірки. Тому вимога надійності — перевіряти умови там, де 
вони важливі, навіть якщо це приводить до певного (неістотного) сповільнення коду.          

Окремо зауважу, що при відмінності чисел і індексів елементів масиву, які ці числа представляють, 
програма оперує саме числами, а відповідні індекси щоразу калькулює. Можна було би робити і навпаки, 
але дотримуюсь думки, що в багатьох випадках, де є вибір між "сутностями" і їх індексами, варто 
оперувати саме "сутностями" — це спрошує розуміння ситуації при відладці. І це важливо.   

Також в даному випадку можна би було добитись співпадіння чисел з їх індексами у масиві, якщо взяти 
масив, в якому елементи [0] і [1] фіктивні і не використовуються. Це гарний метод, але й не позбавлений 
ризиків — все, що не використовується, може призвести до проблем (і часто приводить!). Тому 
утримуюсь від такого рішення.





