Мета занять — підготувати зацікавлених до ефективної програмістської діяльности. 

Я починав працювати програмістом влітку 91-го і на той час вже цілком міг писати значні обʼєми коду — і писав, і запускав у роботу, і отримував з/п. Але за минулі 30 років навчився ще багато чого нового і важливого — відтак, готовий (спробувати) викласти, в чому суть цих додаткових знать. Сиріч, що знає-вміє досвідчений програміст, але не вмів програміст-початківець. Мій професійний профіль: https://www.linkedin.com/in/pavlo-dzikovsky-311045187/

Планую акцентуватись на наступних напрямах викладу, переміжаючи їх. Теорія: B, потім D. Практика: C, потім E (хотілось би починати саме з пункту E, але це не виглядає добрим рішенням). Загальні розмови: A. 

В якості мов для практики будуть використовуватись Golang і, в меншій мірі, Java Script (Node.js, Vue.js) та Python. Також торкнемось особливостей C/C++, Java, Perl і PHP.


A. Загальне (все це може бути потім деталізовано в окремі заняття).

A.1. Поверхневий огляд — програмування як:
- мистецтво (зокрема — алгоритм двох стеків Дейкстри, пошук по списку з результатом пошуку в якості стоп-елемента, обробка дерева з допомогою рекурсії в глибину чи в ширину vs. обробка дерева з допомогою стеку чи черги тощо), ієрархічні конструкції;
- наука (зокрема — складність алгоритмів, спроби аксіоматизації, декремент циклу тощо);
- ремесло (зокрема — планування роботи, акуратність і правила стилю, тести і відладка тощо).

A.2. Поверхневий огляд — історія мов і концепцій програмування:
- перші компʼютери і перші високорівневі мови - фортран, алгол, лісп;
- продуктивність і системи вводу-виводу ранніх компʼютерів;
- компільовані та інтерпретовані мови;
- оцінки вартости програмних систем, ціна помилок, бум мов програмуванні і методології в 70-х;
- структурне та ієрархічне програмування, відмова від goto;
- ООП;
- Model-View-Controller;
- модульне програмування, інтерфейси;
- клієнт-сервер.

А.3. Поверхневий огляд — історія інтернету, персональних компʼютерів, особливості програмного та інтернет-бізнесу.

А.4. Поверхневий огляд — робота і бізнес в IT. Погляд підприємця-роботодавця, тім-ліда, члена команди, кандидата... Звертання-відповідь, запитання-автономність, співпраця, результати.


B. Методи.

B.1. Розробка — спершу в голові. Чіткість/гнучкість планів. Ідеал: TDD/BDD, "Test first / docs first." Реальність: "в бізнесу ніколи немає грошей, щоб розробити систему як слід, зато вони завжди знаходяться на те, щоб розробити її двічі."

B.2. Імплементація елементів системи, тест-кейси. Single responsibility.

B.3. Стиль оформлення коду: форматування (зокрема — стандарти і авто-форматери), лінтери. Програма для читача, програма для для дебагу-підтримки vs. програма для машини. Гівнокод.

B.3. Ієрархічна побудова, проєктування "зверху-вниз". Структурне програмування.

B.4. Відладка — контрольні виводи vs. інтегрований відладчик; уявна прокрутка; STDOUT/STDERR і логи (чистота!); трасування в розподілених системах; прогулянка-роздуми як найсильніший хід. Сильна типізація в мові програмування — мінус половина проблем при відладці.

B.5. Інтерфейси, поліморфізм, наслідування. Composition over inheritance. "Види інтерфейсів" в Go.

B.6. Архітектура системи: Model-View-Controller...

B.7. Модульна/пакетна структура системи: публічні репозиторії і каталоги (NPM), внутрішня структура, Dependency Injection.

B.8. Юніт-тести та інтегральне тестування (ціна помилки: хвилина при компіляції - година при тестуванні - день при відладці). 

B.9. Документація та коментування (зокрема: історія RFC, коментарі в Go, doc-strings в JS/Python). Кращий коментар — добрий код. Але — необхідне коментування мотивів і девіяцій.

B.10. Типічні помилки і критерії оцінки: швидкість vs. надійність :-); "майже робоча система"; акуратність коду; стабільність системи і легкість підтримки-відладки... 

B.11. KISS. YAGNI. If it ain't broke, don't fix it.

B.12. Життєвий цикл розробки і підтримки. Agile, scrum, waterfall, kanban... PoC, MVC, alpha-beta releases, release-candidate, release. Оточення: develop, test, stage, production. Тести, контроль цілісности, аналіз невдач ("post mortem").


C. Структури даних і алгоритми. Практичне кодування і оцінки швидкодії.

C.0. Побіжний огляд інструментів, приклад коду, перші практичні задачі на основі викладеного.

C.1. Масив, багатовимірний масив і список; цикл по масиву і цикли по багатовимірному масиву, множення матриць, імплементація списків.

C.2. Стек (LIFO) і черга (FIFO); алгоритм двох стеків Дейкстри; callback-цикл в Node.js.

C.3. Структура vs. асоціятивний масив (Go map, JS object, Python dict, Perl hash). Швидкодія!

C.4. Деревовидні структури і, на загал, графи. Рекурсія.

C.5. Рядки і регулярні вирази.

C.6. Пошук: перебір vs. бінарний пошук vs. пошук по індексу vs. ще якось? оцінки швидкости. 

C.7. Сортування: бульбашкове vs. сортування вставкою vs. швидке vs. сортування злиттям vs. ще якось? оцінки швидкости. 

C.8. Індексація: збалансовані дерева (B-tree, червоно-чорні дерева), ще щось? оцінки швидкости. 

C.9. Архітектура БД: схема, індекси, foreign keys, нормалізація-денормалізація, тригери.

C.10. Загальне: ієрархія (зокрема: фронт-бек, стек мережевих протоколів...), швидкодія vs. необхідний обʼєм памʼяти, швидкість розробки vs. ціна підтримки.


D. Інструменти. 

D.1. Принципи вибору. Консерватизм vs. new features (тільки необхідне — "Try to do better. By Mick", фреймворки, ORM, IDE, debugger, мій "JSON", ETL-інструменти). Google в поміч :-) Stack Overflow.

D.2. Побіжний огляд базового інструментарію — IDE (VS Code, IntelliJ IDEA, Atom, Eclipse, NetBeans, VIM, Emacs), менеджери пакетів (NPM/Yarn - package.json/package-lock.json, Go modules - go.mod/go.sum, Python PIP), debugger, profiler, version control (Git, GitHub, GitLab, Bitbucket), project management (Trello, JIRA, Confluence), що ще я забув?

D.3. Version control: Git, GitHub, GitLab, Bitbucket. Коміти, гілки, merge (pull) requests. Git flow.

D.4. Типізовані і нетипізовані, компільовані та інтерпретовані мови програмування. Під капотом - асемблер, байт-код, JIT-компіляція. Етап компіляції vs. runtime. Перехід з Node.js на Golang — апріорні перестороги, швидкодія, простота відладки.

D.5. Фреймворки: для Node.js - Express (KOA, Loopback, etc.), для фронт-енда — Angular/React/Vue (React Native), для Python - Django/Flask... Тестові фреймворки, OpenAPI (Swagger).

D.6. Бази даних: SQL (PostgresSQL, MySQL, Amazon Redshift, Google BigQuery) vs. NoSQL (document DB - MongoDB, key-value storages); client-server vs. embedded DB (SQLite, key-value storages); ORM. https://db-engines.com/en/ranking

D.7. Third-party APIs. Власний кодинг vs. сторонні інструменти. Освоєння — від найпростішого. Правило для спеціялістів: "якщо нічого иншого не допомагає, спробуйте почитати документацію".

D.8. Кешування, in-memory DB (Redis). Швидкодія!

D.9. Мови серіялізації та конфігів: JSON, Protobuf, YAML, XML тощо.

D.10. WWW: Email, FTP, Telnet/SSH, HTTP, HTML/HTML5, Wiki markup...

D.11. Клієнт-серверні протоколи: REST, GRPC, GraphQL...

D.12. Хостинг (AWS, Google Cloud, місцеві провайдери), Cloud/SaaS-інструменти (Google Firebase, AWS S3, AWS Lambda, etc.)

D.13. Деплоймент — конвеєри, тести, бекапи, моніторинг/метрики...



E. Практична побудова систем.

E.1. Web-сервер: REST vs. HTML pages generation. Розробка сервера для цих курсів.

E.2. ETL (extract-transform-load). Розробка системи збору новин.

